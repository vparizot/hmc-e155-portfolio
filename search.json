[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "AI Chat Bots: Kahnmigo + Chat GPT\n\n\n\n\n\n\n\n\n\n\n\nSep 11, 2024\n\n\nVictoria Parizot\n\n\n\n\n\n\n\n\n\n\n\n\nThe Embedded Systems Surrounding us\n\n\n\n\n\n\n\n\n\n\n\nSep 11, 2024\n\n\nVictoria Parizot\n\n\n\n\n\n\n\n\n\n\n\n\nAn Exploration of the Hidden Aesthetics of Electrical Components\n\n\n\n\n\nThe Design Behind Segment Displays\n\n\n\n\n\nSep 5, 2024\n\n\nVictoria Parizot\n\n\n\n\n\n\n\n\n\n\n\n\nLearning Goals of MicroPs\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nVictoria Parizot\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Learning Goals of MicroPs",
    "section": "",
    "text": "I am currently taking MicroPs, a course where I can engage hands-on with embedded systems. In this course, I will improve both technical and professional skills. My main goal is to improve my confidence and ability with both FPGAs and MCUs!"
  },
  {
    "objectID": "posts/post2.html",
    "href": "posts/post2.html",
    "title": "An Exploration of the Hidden Aesthetics of Electrical Components",
    "section": "",
    "text": "This week I worked through and completed lab 1. Learn more about the specifications and implementation of lab 1 here. This blog is heavily inspired by Michiel de Boer (Posy)’s video on segmented displays.\nAs part of this lab, I worked to make a seven segment display count in hexadecimal based on the binary value of a DIP switch. Two requirement of the lab was that the:\n“7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF”\n“All digits are unique”\nThroughout the week, I was impressed how seven equally sized segments arranged in two stacked squares was able to display unique digits and letters A thru F. I also saw different ways people deployed the display to represent the number and letters – using lowercase, uppercase, centering on different sides, and so on. This led me to look more at the design of segmented displays.\nThe first recorded segmented display is from a 1903 patent by Carl Kingsey as a way to improve telegraph speeds. Since then, countless different segmented displays for different purposes has emerged.\nPerhaps the most common display is the stacked square design, which I used in lab 1. Looking closely at the display, you can observe the compromises that had been made to simplify the representation of numbers and some letters to fit into 7 equally sized segments. However, these inaccuracies have been heavily normalized to the point where I no longer recognize them. This design has been so heavily widespread that these digit representations are interchangeable with the numbers they represent.\nI ask you to look around your room and see how many segmented displays you can find. I did this exercise in my dorm room and found the segmented display used to show the volume of my speaker, settings of the AC unit, and tell the time from my watch.\nThe different implementations of the segmented display goes to show how small changes are used to improve accuracy and influence aesthetics. For example, the edges of the segments could be rounded or pointed. The middle segment is sometimes slanted. The thickness of the segments change from display to display, and sometimes the entire digit is italicized. Different changes will sacrifice complexity and the look of certain numbers in favor of the look of other numbers and letters.This can be particularly useful for displays that only need to display some of the digits.\nThese seemingly small changes can change the impact of the design, making them suitable for different applications. A seven segmented display on a sports watch will vary from the display of public transport or a toy.\nThis has led me to look more about the design choices made in embedded systems that I interact with. The rest of this blog is dedicated to share different segmented displays that surround me."
  },
  {
    "objectID": "posts/post2.html#segmented-displays-around-me",
    "href": "posts/post2.html#segmented-displays-around-me",
    "title": "An Exploration of the Hidden Aesthetics of Electrical Components",
    "section": "Segmented Displays Around Me",
    "text": "Segmented Displays Around Me\n\n\n\nMultimeter in the digital lab included additional asymetrical segments – My favorite segmented display yet!\n\n\n\n\n\nA Variety of segmented displays available in the engineering stockroom.\n\n\n\n\n\nThe temperature gauge in the engineering building.\n\n\n\n\n\nThe microwave uses a traditional design.\n\n\n\n\n\nThe water fountain uses a matrix display.\n\n\n\n\n\nIt seems like most water fountains use the matrix display."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In Lab 2, I implemented a time-multiplexing scheme to drive two seven-segment displays with a single set of FPGA I/O pins. These displayed two independent hexadecimal numbers read from seperate DIP switches and was driven by a single seven-segment decoder HDL module. I also displayed the sum of the numbers on five LEDs. In doing so, I practiced application of transistors and modular verilog.\nMore information on the lab requirements can be found on the E155 Lab 2 Course Page."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction-learning-objectives",
    "href": "labs/lab2/lab2.html#introduction-learning-objectives",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In Lab 2, I implemented a time-multiplexing scheme to drive two seven-segment displays with a single set of FPGA I/O pins. These displayed two independent hexadecimal numbers read from seperate DIP switches and was driven by a single seven-segment decoder HDL module. I also displayed the sum of the numbers on five LEDs. In doing so, I practiced application of transistors and modular verilog.\nMore information on the lab requirements can be found on the E155 Lab 2 Course Page."
  },
  {
    "objectID": "labs/lab2/lab2.html#design",
    "href": "labs/lab2/lab2.html#design",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design",
    "text": "Design\n\nTo implement this lab, I had to consider: How should I organize this module in Verilog? How fast should I switch between displays? What transistor type should I use? How do I trigger the transistor? Should I use an anode or cathode display? What resisitor values should I use to protect the FPGA? And so on.\nTo work my way through these questions, I drew a block diagram. Essentially I pass through two 4 bit signals from the two DIP switches. I then use the on-board high-speed oscillator to act as an selector signal into a 2-to-1 mux that will select a input signal to pass through the single seven-segment decoder HDL module. I then send the decoded signal to both seven-segment cathod displays. I then utilized the selector signal to drive transistors to trigger each display when needed. By using an NPN transistor, I was able to ensure that the current draw/sink on all FPGA pins are below the currents specified in the recommended operating conditions.\n\n\n\nBlock Diagram\n\n\nThe source code for the project can be found in the associated Github repository."
  },
  {
    "objectID": "labs/lab2/lab2.html#testing",
    "href": "labs/lab2/lab2.html#testing",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Testing",
    "text": "Testing\nTo verify that the design would work as expected, I ran simulations on ModelSim. To do, I instantiated testbenches to test each module. In my testing, I considered edge cases and general cases to examine the behavior of each module. For example, I tested the summing LEDs to ensure that they correctly summed the values of the two DIP switches in binary when they would cause overflow.\nThe wave forms are below, and the behavior is as expected.\n\n\n\nWave forms for validation testing of 2-to-1 mux\n\n\n\n\n\nWave forms for validation testing of summing LEDs\n\n\n\n\n\nWave forms for validation testing of seven segment module"
  },
  {
    "objectID": "labs/lab2/lab2.html#implementation",
    "href": "labs/lab2/lab2.html#implementation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Implementation",
    "text": "Implementation\nAfter confirming that my design would work in simulation, it was time to wire everything up based on the following circuit schematic. In my design, I used a cathode seven segment display along with NPN transistors for each digit.\nSince the display requires substantial current, more than an FPGA output pin can drive, I used an NPN transistor to drive the large current. To calculate the resistor values, I went to the data sheet and found that FPGA pins drive at 3.3 V and 8 mA.\n\n\n\nResistor calculations for NPN transistors\n\n\nI also implemented the necessary resistors for all led display, based on lab 1 calculations.\n\n\n\nCircuit Schematic\n\n\nHere is a video of the completed design! Completed design demo!\nThrough trial and error, a suitable switching speed was found so that both sides of the display look like they are on!"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\n\n\nLab 2 provided an introduction to implementing multiplexing in a visual manner. As a result, I grew more familiar with the different type of transistors and calculations for current draw.\nLab 2 meets all the requirements, and took me approximately 13 hours."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, I familiarized myself with the STM32L432KC microcontroller unit (MCU) and UPduino v3.1 field-programmable gate array (FPGA) development boards I will be using throughout the semester. This involved assembling my board, initial testing, and implementing Verilog to control LEDs and a 7-segment display using Radiant, Segger Embedded Studio, and ModelSim.\nMore information on the lab requirements can be found on the E155 Lab 1 Course Page."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction-learning-objectives",
    "href": "labs/lab1/lab1.html#introduction-learning-objectives",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, I familiarized myself with the STM32L432KC microcontroller unit (MCU) and UPduino v3.1 field-programmable gate array (FPGA) development boards I will be using throughout the semester. This involved assembling my board, initial testing, and implementing Verilog to control LEDs and a 7-segment display using Radiant, Segger Embedded Studio, and ModelSim.\nMore information on the lab requirements can be found on the E155 Lab 1 Course Page."
  },
  {
    "objectID": "labs/lab1/lab1.html#development-board-soldering-and-set-up",
    "href": "labs/lab1/lab1.html#development-board-soldering-and-set-up",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Development Board: Soldering and Set up",
    "text": "Development Board: Soldering and Set up\nThe first step was to assemble the custom printed circuit board which hosts the MCU and FPGA boards. This involved sodering both surface mount technology (SMT) and through hole technology (THT) components, based on the provided BOM.\n\n\n\nCompleted E155 Development Board\n\n\nAfter soldering, it was time to power up and test the board. To do so, I programmed the FPGA using Lattice Radiant and Segger Embedded Studio to toggle LED pins at predetermined frequencies. After confirming my board worked as expected, it was time to implement LEDs and the 7 segment display."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-implementation",
    "href": "labs/lab1/lab1.html#design-implementation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design & Implementation",
    "text": "Design & Implementation\n\n\nLab Requirements\nThe next step was to program three LEDs and a seven segment display. The seven segment display is to read four DIP switch signals, s, as a 4 bit binary value and display that value in hexidecimal. The behavior of the LEDs are described by the following tables.\n\n\n\n\nSignal Name\n\n\nSignal Type\n\n\nDescription\n\n\n\n\n\n\nclk\n\n\ninput\n\n\n48 MHz clock on FPGA\n\n\n\n\ns[3:0]\n\n\ninput\n\n\nthe four DIP switches (on the board, SW6)\n\n\n\n\nled[2:0]\n\n\noutput\n\n\n3 LEDs (you may use the on-board LEDs)\n\n\n\n\nseg[6:0]\n\n\noutput\n\n\nthe segments of a common-anode 7-segment display\n\n\n\n\n\nThe following tables define the relationship of the LEDs to the switches and clock.\n\n\n\n\n\n\nS1\n\n\nS0\n\n\nled[0]\n\n\n\n\n\n\n0\n\n\n0\n\n\nOFF\n\n\n\n\n0\n\n\n1\n\n\nON\n\n\n\n\n1\n\n\n0\n\n\nON\n\n\n\n\n1\n\n\n1\n\n\nOFF\n\n\n\n\n\n\n\n\n\n\nS3\n\n\nS2\n\n\nled[1]\n\n\n\n\n\n\n0\n\n\n0\n\n\nOFF\n\n\n\n\n0\n\n\n1\n\n\nOFF\n\n\n\n\n1\n\n\n0\n\n\nOFF\n\n\n\n\n1\n\n\n1\n\n\nON\n\n\n\n\n\n\n\n\n\n\nled[2]\n\n\n\n\n\n\nBlink at 2.4 Hz\n\n\n\n\n\n\n\n\nDesign\nTo organize my thoughts I used a block diagram to map the logic.\n\n\n\nLab 1 Block Diagram\n\n\n\nLed Logic Design\nThe truth tables revealed that led[0] behaves as an XOR gate with inputs S1 and S0 and that led[1] behaves as an AND gate with inputs S3 and S2.\nTo have led[2] to blink at 2.4 Hz, I utilized the internal 48 gHz high speed oscillator from the HSOSC Library. A frequency of 2.4 Hz would have a full cycle of 0.4167 second. Dividing this by the frequency of the internal oscillator, we get that a full cycle would require \\(2*10^7\\) ticks. To achieve a duty cycle of 50%, I implemented a flip flop that switched led[2] every \\(10^7\\) clicks.\n\n\nSeven Segment Logic Design\nTo interface the seven segment display with the board, I conferred with the datasheet to determine resistor values. \n\n\n\nResistor Calculations for Seven Segment Display\n\n\nI opted to use resistor values of 240 ohms, producing 6.25 mA of current.\nA wiring schematic is shown below. \nHere is a photo of the implemented design!"
  },
  {
    "objectID": "labs/lab1/lab1.html#testing",
    "href": "labs/lab1/lab1.html#testing",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Testing",
    "text": "Testing\n\nTo verify that the design would work as expected, I ran simulations on ModelSim. To do, I instantiated a test bench that would test all 16 possible inputs of the dip switch to ensure the LED and seven segment display output as expected.\n\n\n\nWave forms of test bench\n\n\nI tested the blinking led[2] with the oscilliscope to confirm it had a frequency of 2.4 hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\n\n\nIn all, Lab 1 offered a cohesive introduction to the work flow for the coming labs. I was able to practice my sodering technique, interfacing with different software, assigning pins, and testing my design with ModelSim.\nThe design meets all the requirements. I spent roughly 15 hours on this lab."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In Lab 3, I designed and constructed a circuit on my FPGA to read a 4-by-4 matrix keypad and display the last two hexadecimal digits pressed on dual seven-segment displays. My design satisfied all the requirements, including:\n\n\nDesign does not lock up when multiple buttons are pressed at once.\n\n\nDesign only registers first button press if additional buttons are pressed down while holding down one button.\n\n\nEach button press registered only once (e.g., no switch bouncing)\n\n\nSeven segment displays are same brightness regardless of how many segments are illuminated.\n\n\nDesign has no latches.\n\n\nDesign has no tristate buffers.\n\n\nDesign uses synchronizers on asynchronous inputs to mitigate metastability.\n\n\nThe source code for the project can be found in the associated Github repository."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction-learning-objectives",
    "href": "labs/lab3/lab3.html#introduction-learning-objectives",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In Lab 3, I designed and constructed a circuit on my FPGA to read a 4-by-4 matrix keypad and display the last two hexadecimal digits pressed on dual seven-segment displays. My design satisfied all the requirements, including:\n\n\nDesign does not lock up when multiple buttons are pressed at once.\n\n\nDesign only registers first button press if additional buttons are pressed down while holding down one button.\n\n\nEach button press registered only once (e.g., no switch bouncing)\n\n\nSeven segment displays are same brightness regardless of how many segments are illuminated.\n\n\nDesign has no latches.\n\n\nDesign has no tristate buffers.\n\n\nDesign uses synchronizers on asynchronous inputs to mitigate metastability.\n\n\nThe source code for the project can be found in the associated Github repository."
  },
  {
    "objectID": "labs/lab3/lab3.html#design",
    "href": "labs/lab3/lab3.html#design",
    "title": "Lab 3: Keypad Scanner",
    "section": "Design",
    "text": "Design\nTo quote Professor Brake, “This is a thinking person’s lab.” As such, I spent a fair amount of time designing a Finite State Machine (FSM) to read the in the matrix keypad inputs, and then creating a block diagram to understand how my modules will intersect.\n\nScanning FSM\nThe FSM to read the inputs worked by cycling through pulling each row to high, and looking to see if any of the columns were high, which was tracked in the keyPressed variable. If the FSM found that a key was pressed, it would enter a waiting stage until the button was unpressed. I handled decoding the row and colomn pairs wihtin my FSM module with my scanDecoder module. This allowed me to output the keyDecoded, keyPressed, and the rows from the scanFSM module to interact with other modules. \n\n\nKey Debouncing FSM\nI then passed through keyDecoded and keyPressed into the keyBounce module, that used an FSM to deal with key debouncing. This FSM had four states: a waiting state, a counting state, a printing state, and then a holding state. The FSM is in the waiting state until keyPressed is high. Once the key is pressed, a counter is triggered. Once the counter reaches a threshold value, then an enabled signal is activated and the signal is displayed on the seven segment display. Then the FSM enters the holding state until the button is unpressed.\n\n\n\nButton Debouncing FSM\n\n\n\n\nSeven Segment Display\nWith the keyBounce FSM, a shifter module was called to shift the display on the dual seven segment display and show the new value. The keyBounce FSM ultimately served to disregard quick, high signals.\nPrinting and multiplexing the seven segment display was handled with the code from Lab 2\n\n\nDesign Tradeoffs\n\nMy design was broken up into many different modules, with different FSMs or combinational logic being used to implement my design. I opted for this approach so that it would be easier to test smaller behaviors, and allowed me to edit functionalities without impacting other functionalities.\nFor example, to implement switch debouncing, I implemented a FSM with different states. At first, I attempted an approach without an FSM – using a lot of if statements. However, as the behavior got more complicated, I started to infer latches. To stop this, I opted to draw an FSM so that I can step away from “thinking like a programmer” and start thinking about the hardware.\nA block diagram of my entire design is here:"
  },
  {
    "objectID": "labs/lab3/lab3.html#simulation-and-testing",
    "href": "labs/lab3/lab3.html#simulation-and-testing",
    "title": "Lab 3: Keypad Scanner",
    "section": "Simulation and Testing",
    "text": "Simulation and Testing\nThe first step here was to test all the modules in modelSim before running on Radiant. This avoided many headaches – as I wrote test benches for each individual model to ensure expected behavior.\nMy waveforms for each model is below: \n\n\n\nShifter Test Bench\n\n\n\n\n\nkeyBounce Test Bench\n\n\nMy mux, sum, and sevensegments module was taken from Lab 2, where I implemented test benches last week."
  },
  {
    "objectID": "labs/lab3/lab3.html#implementation",
    "href": "labs/lab3/lab3.html#implementation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Implementation",
    "text": "Implementation\nThe circuit diagram of my implementation, including pin mapping, is here: \n\nDebugging in Implementation\nDuring the implementation of my design, I encountered a few bugs. In doing so, using the oscilloscope ot visualize which rows are high allowed me to isolate bugs in my FSM. Additionally, the oscilloscope helped me decide the threshold value for my key debouncing module.\n\n\nHandling Metastability\nTo handle metastability, I implemented two flip flops and temporary variables to try to line the async input with the clock edge."
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Conclusion",
    "text": "Conclusion\nLab 3 proved that simulation prior to implementation is a necessity. As a result, I grew familiar with fully defining my system, and how to debug.\nLab 3 meets all the requirements, and took me approximately 30 hours to complete"
  },
  {
    "objectID": "posts/post4.html",
    "href": "posts/post4.html",
    "title": "AI Chat Bots: Kahnmigo + Chat GPT",
    "section": "",
    "text": "A few weeks ago, Sal Khan came to speak at my school. I remember watching his videos when I was young to learn how to factor and simplify exponents – so I had to go to his talk. In his talk, he talked about Khanmigo, Khan Academy’s AI-Powered teaching assistant. He explained its many benefits, including helping students complete assignments and assisting teachers create lesson plans through personal, albeit experimental, help. His perspective of using AI as an assistant emphasized increased throughput while still preserving effort, allowing teachers and students to be more effective with their time.\nHearing about AI being incorporated into a platform that I grew up using was exciting to me. In the past year, we have witnessed a crazy progression of AI as it gets incorporated into existing products – Nearly every search engine includes AI generated answers, Adobe products have started to include generative fill, and social media has started using AI to maximize engagement. Like many, I am suprised by how quickly AI Chat Bots have improved.\nI remember last winter break showing my mom ChatGPT. I just completed a class on Zora Neale Hurston, with my final paper analyzing one of her books. In an effort to show my mom how quickly ChatGPT can generate content, I asked it to create a final paper for the same prompt, using my original bare-bone outline. We were both impressed as ChatGPT delivered a polished paper, including quotations and references to her other works. However, upon closer inspection, I realized that I did not recall any of the ChatGPT proclaimed quotes from the book. Instead, these ‘quotes’ were made up to support ChatGPT’s arguments, using the similair langauge style that Hurston had used.\nThis caused me to reconsider the strengths and weaknesses of AI Chat Bots. They can be useful in idea generation and pointing someone in the general direction, however lose accuracy in details.\nWith this personal experience under my belt, I was hesitant at Sal Khan’s optimism about Khanmigo. What would happen in Khanmigo was wrong about something as a student learns the fundamentals?\nUpon hearing more of his talk, I felt reassured about the testing and features that they have choosed Khanmigo to support. It is refreshing to see AI used to increase the efficiency of learning, rather than as a way to avoid learning."
  },
  {
    "objectID": "posts/post3.html",
    "href": "posts/post3.html",
    "title": "The Embedded Systems Surrounding us",
    "section": "",
    "text": "Throughout this course, I have been working with an MCU and FPGA extensively. As I do so, I admire the reprogrammable aspects, allowing me to test and implement a variety of systems. On the other end of this “reusability spectrum” spectrum lies the embedded system, which a specialized computer system for a specific task. In my blog this week, I want to look more at the embedded systems that surround me.\nFor starters, I wear an apple watch – a combination of sensors, software, and hardware on my wrist. This specialized system is able to monitor my daily steps, heartbeat, movements, as well as connect with my phone to share text messages. The apple watch uses an accelerometer, a gyroscope, a barometer, a Force Touch Sensor, and a Heart Rate Sensor. The accelerometer and gyroscope are critical for detecting orientation and movements – and seem quite intuitive to include. The barometer seems less intuitive – however the pressure readings can indicate elevation changes. The Force Touch Sensor is useful for inputing user’s intentions as they touch the screen. Finally, the Heart Rate Sensor uses photoplethysmography (light) to measure heart rate. I am always amazed by the accuracy of the apple watch. I often use my watch to record my swim workouts, and sometimes compare the stroke breakdown and yardage to reality, and am impresssed by how similair it is.\n\nAnother embedded system is my digital camera, which is able to perform image processing, autofocus, exposure, and picture stabilization. It features a variety of settings, spanning from completely manual to specialized automatic modes – like portrait and landscape mode.\nAir conditioning is also another embedded system. We recently just had a heat wave, with temperatures reaching 112 degrees. During which, the air conditioning broke. The HVAC system used in my dorm required replacements for highly specialized parts, which were difficult to source. This points out a down side of embedded systems – due to their task-specific nature, as embedded systems phase out, the parts and documentation can be hard to find."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Victoria Parizot - Norwalk, CT\nVictoria Parizot is a senior at Harvey Mudd College, majoring in engineering. She is most interested with mechanical and electrical engineering, and excited to be taking “Microprocessor Systems: Design & Application” (AKA MicroPs)!\nAt Harvey Mudd, she is a West Dorm President and a Machine Shop Proctor. In her free time, she enjoys woodworking in the machine shop, taking and developing film photos, and sailing."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "MicroPs Resources",
    "section": "",
    "text": "To learn more about the MicroPs Course, and the motivation of the labs, look at the MicroPs website."
  }
]