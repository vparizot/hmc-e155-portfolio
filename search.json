[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "The Art in PCB Design\n\n\n\n\n\n\n\n\n\n\n\nNov 2, 2024\n\n\nVictoria Parizot\n\n\n\n\n\n\n\n\n\n\n\n\nConsiderations of an AI Chat Bot\n\n\n\n\n\n\n\n\n\n\n\nSep 11, 2024\n\n\nVictoria Parizot\n\n\n\n\n\n\n\n\n\n\n\n\nThe Embedded Systems Surrounding us\n\n\n\n\n\n\n\n\n\n\n\nSep 11, 2024\n\n\nVictoria Parizot\n\n\n\n\n\n\n\n\n\n\n\n\nAn Exploration of the Hidden Aesthetics of Electrical Components\n\n\n\n\n\nThe Design Behind Segment Displays\n\n\n\n\n\nSep 5, 2024\n\n\nVictoria Parizot\n\n\n\n\n\n\n\n\n\n\n\n\nLearning Goals of MicroPs\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nVictoria Parizot\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Learning Goals of MicroPs",
    "section": "",
    "text": "I am currently taking MicroPs, a course where I can engage hands-on with embedded systems. In this course, I will improve both technical and professional skills. My main goal is to improve my confidence and ability with both FPGAs and MCUs!"
  },
  {
    "objectID": "posts/post2.html",
    "href": "posts/post2.html",
    "title": "An Exploration of the Hidden Aesthetics of Electrical Components",
    "section": "",
    "text": "This week I worked through and completed lab 1. Learn more about the specifications and implementation of lab 1 here. This blog is heavily inspired by Michiel de Boer (Posy)’s video on segmented displays.\nAs part of this lab, I worked to make a seven segment display count in hexadecimal based on the binary value of a DIP switch. Two requirement of the lab was that the:\n“7-segment display can display all sixteen hexadecimal digits from 0x0 through 0xF”\n“All digits are unique”\nThroughout the week, I was impressed how seven equally sized segments arranged in two stacked squares was able to display unique digits and letters A thru F. I also saw different ways people deployed the display to represent the number and letters – using lowercase, uppercase, centering on different sides, and so on. This led me to look more at the design of segmented displays.\nThe first recorded segmented display is from a 1903 patent by Carl Kingsey as a way to improve telegraph speeds. Since then, countless different segmented displays for different purposes has emerged.\nPerhaps the most common display is the stacked square design, which I used in lab 1. Looking closely at the display, you can observe the compromises that had been made to simplify the representation of numbers and some letters to fit into 7 equally sized segments. However, these inaccuracies have been heavily normalized to the point where I no longer recognize them. This design has been so heavily widespread that these digit representations are interchangeable with the numbers they represent.\nI ask you to look around your room and see how many segmented displays you can find. I did this exercise in my dorm room and found the segmented display used to show the volume of my speaker, settings of the AC unit, and tell the time from my watch.\nThe different implementations of the segmented display goes to show how small changes are used to improve accuracy and influence aesthetics. For example, the edges of the segments could be rounded or pointed. The middle segment is sometimes slanted. The thickness of the segments change from display to display, and sometimes the entire digit is italicized. Different changes will sacrifice complexity and the look of certain numbers in favor of the look of other numbers and letters.This can be particularly useful for displays that only need to display some of the digits.\nThese seemingly small changes can change the impact of the design, making them suitable for different applications. A seven segmented display on a sports watch will vary from the display of public transport or a toy.\nThis has led me to look more about the design choices made in embedded systems that I interact with. The rest of this blog is dedicated to share different segmented displays that surround me."
  },
  {
    "objectID": "posts/post2.html#segmented-displays-around-me",
    "href": "posts/post2.html#segmented-displays-around-me",
    "title": "An Exploration of the Hidden Aesthetics of Electrical Components",
    "section": "Segmented Displays Around Me",
    "text": "Segmented Displays Around Me\n\n\n\nMultimeter in the digital lab included additional asymetrical segments – My favorite segmented display yet!\n\n\n\n\n\nA Variety of segmented displays available in the engineering stockroom.\n\n\n\n\n\nThe temperature gauge in the engineering building.\n\n\n\n\n\nThe microwave uses a traditional design.\n\n\n\n\n\nThe water fountain uses a matrix display.\n\n\n\n\n\nIt seems like most water fountains use the matrix display."
  },
  {
    "objectID": "posts/post4.html",
    "href": "posts/post4.html",
    "title": "Considerations of an AI Chat Bot",
    "section": "",
    "text": "Last week, Sal Khan came to speak at my school. As someone who learned how to factor from his videos, I was very excited for it. In his talk, he introduced Khanmigo, Khan Academy’s AI-Powered teaching assistant. He explained its many benefits, including helping students complete assignments and assisting teachers create lesson plans through personal, albeit experimental, help. His perspective of using AI as an assistant emphasized increased throughput while still preserving effort, allowing teachers and students to be more effective with their time.\nHearing about AI being incorporated into a platform that I grew up using was exciting to me. In the past year, we have witnessed a crazy progression of AI as it gets incorporated into existing products – Nearly every search engine includes AI generated answers, Adobe products have started to include generative fill, and social media has started using AI to maximize engagement. Like many, I am suprised by how quickly AI Chat Bots have improved.\nI remember last winter break showing my mom ChatGPT. I just completed a class on Zora Neale Hurston, with my final paper analyzing one of her books. In an effort to show my mom how quickly ChatGPT can generate content, I asked it to create a final paper for the same prompt, using my original bare-bone outline. We were both impressed as ChatGPT delivered a polished paper, including quotations and references to her other works. However, upon closer inspection, I realized that I did not recall any of the ChatGPT proclaimed quotes from the book. Instead, these ‘quotes’ were made up to support ChatGPT’s arguments, using the similair langauge style that Hurston had used. This caused me to reconsider the strengths and weaknesses of AI Chat Bots. They can be useful in idea generation and pointing someone in the general direction, however lose accuracy in details.\nWith this personal experience under my belt, I was hesitant at Sal Khan’s optimism about Khanmigo. What would happen in Khanmigo was wrong about something as a student learns the fundamentals? This could negatively impact their education.\nWith this uncertainty in mind, it was interesting to learn the ways Khan Academy has minimized this risk. The plentiful testing and carefully choosen features lend itself to AI.\nMoreover, it was refreshing to see AI implemented cautiously, and for the overall goal of imoproving education access. Many implementations of AI seem to be a rushed reaction to the AI movement, and used to sell a product. Overall, his talk made me hopeful for the future of AI."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In lab 4 I used an MCU to play music by using timers to generate square waves by toggling a GPIO pin at a specific frequency for specified durations.\nTo build a system to play music, I used an LM386 audio amplifier, and an 8-ohm speaker. The MCU read a list of notes and generated a corresponding sequence of square waves. For this lab, we were NOT allowed to use CMSIS headers, forcing us to define our own structs to better understand the MCU registers and better familiarize ourselves with reading the Reference manual.\nThis lab had the following learning objectives:\n\n\nBuilt a circuit to enable an I/O pin from your MCU to drive a speaker\n\n\nImplemented the timer functionality available on the MCU by reading the datasheet and writing your own library in C from scratch\n\n\nThe source code for the project can be found in the associated Github repository."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction-learning-objectives",
    "href": "labs/lab4/lab4.html#introduction-learning-objectives",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In lab 4 I used an MCU to play music by using timers to generate square waves by toggling a GPIO pin at a specific frequency for specified durations.\nTo build a system to play music, I used an LM386 audio amplifier, and an 8-ohm speaker. The MCU read a list of notes and generated a corresponding sequence of square waves. For this lab, we were NOT allowed to use CMSIS headers, forcing us to define our own structs to better understand the MCU registers and better familiarize ourselves with reading the Reference manual.\nThis lab had the following learning objectives:\n\n\nBuilt a circuit to enable an I/O pin from your MCU to drive a speaker\n\n\nImplemented the timer functionality available on the MCU by reading the datasheet and writing your own library in C from scratch\n\n\nThe source code for the project can be found in the associated Github repository."
  },
  {
    "objectID": "labs/lab4/lab4.html#mcu-design",
    "href": "labs/lab4/lab4.html#mcu-design",
    "title": "Lab 4: Digital Audio",
    "section": "MCU Design",
    "text": "MCU Design\nThe MCU read a list of notes specifying pitch (in Hz) and duration (in ms) and generated a corresponding sequence of square waves. To implement this, I used the built-in MSI clock to initialize two timers: Timer 15 to handle duration of each note and Timer 16 to use Pulse Width Modulation (PWM) capabilities to generate the desired pitch. These timers would work together to generate desired square waves out of PA6. This approach is outlined in the image below.\n\n\n\nMCU Timer Design Outline\n\n\n\nMSI Clock\nI set the MSI Clock at it’s default frequency of 4 Mhz. The clock’s output frequency can be calculated with: \\(Output freq = (srcclk) * (N/M) / R\\)\nI set N = 16, M = 1 and R = 16, to abide by N, M, R constraints.\nThe Clock set up was dealt with in my RCC files.\n\n\nDelay Timer (TIM 15)\nTimer 15 was used as the delay timer, and initialized with the initTIMdelay(TIM_TypeDef15 * TIMx). As the delay timer would ultimately read in ms, I opted to scale down my clock from 4Mhz to 100 kHz. This was done by setting the prescaler to 39.\n\\(Timer freq = \\frac{clkfreq}{PSC + 1} = \\frac{4 MHz}{40} = 100 kHz\\)\nTo use the delay timer, I implemented a delay_millis function, that took in a pointer to the Timer to use and an integers of the ms to delay for. The function utilized the ARR register, CNT register, and SR register to wait for x ms.\nThe Auto Reload Register (ARR) represents the maximum value that a timer can count to, where the count is incremented at the Timer frequency. Since our TIM15 frequency is 100 kHz, then the CNT register increments by 100 every millisecond. Therefore, the ARR was set to \\(100*ms_{desired}\\). The Counter (CNT) and Capture/Compare 1 (SR) were reset.\nOnce the ARR is reached, the Status Register (SR) will change from 0 to 1. Thus, I implemented a while loop that waited until the flag was reached.\nTo understand the limitations of the delay function, we can calculate the maximum and minimum durations supported.\n\nMaximum Delay Supported\nThe ARR is a 16 bit number, meaning the maximum value of \\(ARR = 2^{16} - 1\\) Given the relationship that \\(ARR = 100*ms_{desired}\\), the maximum wait time is \\(\\frac{2^{16} - 1}{100} = 655.35ms\\)\nIf I wanted to delay for longer, I could call the delay function multiple times, reset the counter during the loop, or further slow the clock.\n\n\nMinimum Delay Supported\nThe minimum value of \\(ARR = 1\\), doing similair calculations as before,\n\\(\\frac{ARR}{100} = \\frac{1}{100} = 0.01ms\\)\nwe see that the minimum delay supported is 0.01ms.\n\n\n\nPulse Width Modulation (PWM) Timer (TIM 16)\nTimer 16 was set up with PWM capabilities to generate square waves representing the frequency of each note. TIM16 was initialied with the initTIMpwm() funtion, that set TIM16 count frequency to 100 kHz with a prescaler of 39, and the PWM duty cyle to 50%. For each note, the desired frequency was passed into a pitch function, which set ARR based on desired frequency, and recalculated for a 50% duty cylce, and triggered an update event. The ARR was calculated as: \\(ARR = \\frac{100 kHz}{desired_{pitch}}\\)\nWe can validate our choice by ensuring that individual pitches are accurate to within 1% across the frequency range of 220-1000 Hz:\n\nPercent Error at 220 Hz\n\\(\\% error = 100*\\frac{{|calculated - actual|}}{actual}\\)\n\\(ARR = \\frac{100 kHz}{pitch_{desired}} = \\frac{100000}{220} = 454.54\\)\nThe ARR would round this to 455, as it counts in integers $calculated = 100 kHz/ 455 = 219.78\n\\(\\% error = 100*\\frac{|219.78 - 220|}{220} = 0.1\\%\\)\n\n\nPercent Error at 1000 Hz\n\\(\\% error = 100*\\frac{{|calculated - actual|}}{actual}\\)\n\\(ARR = \\frac{100 kHz}{pitch_{desired}} = \\frac{100000}{1000} = 100\\)\nThis is an integer value, meanining that no casting would occur, and the frequency would be very precise.\nWe can also calulate the maximum and minimum frequencies supported:\n\n\nMinimum Frequency Supported\nThe ARR is a 16 bit number, meaning the maximum value of \\(ARR_{max} = 2^{16} - 1\\). Given the relationship that \\(ARR = \\frac{100 kHz}{desired_{pitch}}\\), the minimum frequncy supported is\n\\(min_{pitch} = \\frac{100 kHz}{ARR} = \\frac{100 kHz}{2^{16} - 1}\\) \\(min_{pitch} = 1.5259 Hz\\)\n\n\nMaximum Frequency Supported\nThe maximum value of \\(ARR = 1\\), doing similair calculations as before, \\(max_{pitch} = \\frac{100 kHz}{ARR} = \\frac{100 kHz}{1}\\) = 100 kHz \\(max_{pitch} = 100 kHz\\)\n\n\n\nGPIO (GPIOA)\nTo interface with the frequency that we were generating, I used an alternate function pun. From page 57 on the datasheet, TIM16 correlates to PA6. PA6 was set to an alternate function using pinMode."
  },
  {
    "objectID": "labs/lab4/lab4.html#hardware-design",
    "href": "labs/lab4/lab4.html#hardware-design",
    "title": "Lab 4: Digital Audio",
    "section": "Hardware Design",
    "text": "Hardware Design\nAn LM386 audio amplifier [LM386 Datasheet] was used to interface MCU pin PA6 with an 8 Ohm speaker.\n\n\n\nLab 4 Wiring Diagram"
  },
  {
    "objectID": "labs/lab4/lab4.html#testing-debugging",
    "href": "labs/lab4/lab4.html#testing-debugging",
    "title": "Lab 4: Digital Audio",
    "section": "Testing & Debugging",
    "text": "Testing & Debugging\nThis lab looked a lot at generating signals at desired frequencies and durations. As a result, the oscilloscope was incredible important in ensuring that clock scaling and timer frequencies were as desired."
  },
  {
    "objectID": "labs/lab4/lab4.html#demonstration",
    "href": "labs/lab4/lab4.html#demonstration",
    "title": "Lab 4: Digital Audio",
    "section": "Demonstration",
    "text": "Demonstration\nMy lab played Für Elise from provided starter code at the desired pitch and tempo.\n\nI also tranposed one of the best songs ever to play on my speaker as well:"
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "Lab 4: Digital Audio",
    "section": "Conclusion",
    "text": "Conclusion\nLab 4 provided an introduction into MCU clock and timers. I grew comfortable with reading the 1600 page datasheet, a task that had previously felt daunting.\nLab 4 meets all the requirements, and took me approximately 24 hours to complete."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In Lab 2, I implemented a time-multiplexing scheme to drive two seven-segment displays with a single set of FPGA I/O pins. These displayed two independent hexadecimal numbers read from seperate DIP switches and was driven by a single seven-segment decoder HDL module. I also displayed the sum of the numbers on five LEDs. In doing so, I practiced application of transistors and modular verilog.\nMore information on the lab requirements can be found on the E155 Lab 2 Course Page."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction-learning-objectives",
    "href": "labs/lab2/lab2.html#introduction-learning-objectives",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In Lab 2, I implemented a time-multiplexing scheme to drive two seven-segment displays with a single set of FPGA I/O pins. These displayed two independent hexadecimal numbers read from seperate DIP switches and was driven by a single seven-segment decoder HDL module. I also displayed the sum of the numbers on five LEDs. In doing so, I practiced application of transistors and modular verilog.\nMore information on the lab requirements can be found on the E155 Lab 2 Course Page."
  },
  {
    "objectID": "labs/lab2/lab2.html#design",
    "href": "labs/lab2/lab2.html#design",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design",
    "text": "Design\n\nTo implement this lab, I had to consider: How should I organize this module in Verilog? How fast should I switch between displays? What transistor type should I use? How do I trigger the transistor? Should I use an anode or cathode display? What resisitor values should I use to protect the FPGA? And so on.\nTo work my way through these questions, I drew a block diagram. Essentially I pass through two 4 bit signals from the two DIP switches. I then use the on-board high-speed oscillator to act as an selector signal into a 2-to-1 mux that will select a input signal to pass through the single seven-segment decoder HDL module. I then send the decoded signal to both seven-segment cathod displays. I then utilized the selector signal to drive transistors to trigger each display when needed. By using an NPN transistor, I was able to ensure that the current draw/sink on all FPGA pins are below the currents specified in the recommended operating conditions.\n\n\n\nBlock Diagram\n\n\nThe source code for the project can be found in the associated Github repository."
  },
  {
    "objectID": "labs/lab2/lab2.html#testing",
    "href": "labs/lab2/lab2.html#testing",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Testing",
    "text": "Testing\nTo verify that the design would work as expected, I ran simulations on ModelSim. To do, I instantiated testbenches to test each module. In my testing, I considered edge cases and general cases to examine the behavior of each module. For example, I tested the summing LEDs to ensure that they correctly summed the values of the two DIP switches in binary when they would cause overflow.\nThe wave forms are below, and the behavior is as expected.\n\n\n\nWave forms for validation testing of 2-to-1 mux\n\n\n\n\n\nWave forms for validation testing of summing LEDs\n\n\n\n\n\nWave forms for validation testing of seven segment module"
  },
  {
    "objectID": "labs/lab2/lab2.html#implementation",
    "href": "labs/lab2/lab2.html#implementation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Implementation",
    "text": "Implementation\nAfter confirming that my design would work in simulation, it was time to wire everything up based on the following circuit schematic. In my design, I used a cathode seven segment display along with NPN transistors for each digit.\nSince the display requires substantial current, more than an FPGA output pin can drive, I used an NPN transistor to drive the large current. To calculate the resistor values, I went to the data sheet and found that FPGA pins drive at 3.3 V and 8 mA.\n\n\n\nResistor calculations for NPN transistors\n\n\nI also implemented the necessary resistors for all led display, based on lab 1 calculations.\n\n\n\nCircuit Schematic\n\n\nHere is a video of the completed design! Completed design demo!\nThrough trial and error, a suitable switching speed was found so that both sides of the display look like they are on!"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\n\n\nLab 2 provided an introduction to implementing multiplexing in a visual manner. As a result, I grew more familiar with the different type of transistors and calculations for current draw.\nLab 2 meets all the requirements, and took me approximately 13 hours."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, I familiarized myself with the STM32L432KC microcontroller unit (MCU) and UPduino v3.1 field-programmable gate array (FPGA) development boards I will be using throughout the semester. This involved assembling my board, initial testing, and implementing Verilog to control LEDs and a 7-segment display using Radiant, Segger Embedded Studio, and ModelSim.\nMore information on the lab requirements can be found on the E155 Lab 1 Course Page."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction-learning-objectives",
    "href": "labs/lab1/lab1.html#introduction-learning-objectives",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, I familiarized myself with the STM32L432KC microcontroller unit (MCU) and UPduino v3.1 field-programmable gate array (FPGA) development boards I will be using throughout the semester. This involved assembling my board, initial testing, and implementing Verilog to control LEDs and a 7-segment display using Radiant, Segger Embedded Studio, and ModelSim.\nMore information on the lab requirements can be found on the E155 Lab 1 Course Page."
  },
  {
    "objectID": "labs/lab1/lab1.html#development-board-soldering-and-set-up",
    "href": "labs/lab1/lab1.html#development-board-soldering-and-set-up",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Development Board: Soldering and Set up",
    "text": "Development Board: Soldering and Set up\nThe first step was to assemble the custom printed circuit board which hosts the MCU and FPGA boards. This involved sodering both surface mount technology (SMT) and through hole technology (THT) components, based on the provided BOM.\n\n\n\nCompleted E155 Development Board\n\n\nAfter soldering, it was time to power up and test the board. To do so, I programmed the FPGA using Lattice Radiant and Segger Embedded Studio to toggle LED pins at predetermined frequencies. After confirming my board worked as expected, it was time to implement LEDs and the 7 segment display."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-implementation",
    "href": "labs/lab1/lab1.html#design-implementation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design & Implementation",
    "text": "Design & Implementation\n\n\nLab Requirements\nThe next step was to program three LEDs and a seven segment display. The seven segment display is to read four DIP switch signals, s, as a 4 bit binary value and display that value in hexidecimal. The behavior of the LEDs are described by the following tables.\n\n\n\n\nSignal Name\n\n\nSignal Type\n\n\nDescription\n\n\n\n\n\n\nclk\n\n\ninput\n\n\n48 MHz clock on FPGA\n\n\n\n\ns[3:0]\n\n\ninput\n\n\nthe four DIP switches (on the board, SW6)\n\n\n\n\nled[2:0]\n\n\noutput\n\n\n3 LEDs (you may use the on-board LEDs)\n\n\n\n\nseg[6:0]\n\n\noutput\n\n\nthe segments of a common-anode 7-segment display\n\n\n\n\n\nThe following tables define the relationship of the LEDs to the switches and clock.\n\n\n\n\n\n\nS1\n\n\nS0\n\n\nled[0]\n\n\n\n\n\n\n0\n\n\n0\n\n\nOFF\n\n\n\n\n0\n\n\n1\n\n\nON\n\n\n\n\n1\n\n\n0\n\n\nON\n\n\n\n\n1\n\n\n1\n\n\nOFF\n\n\n\n\n\n\n\n\n\n\nS3\n\n\nS2\n\n\nled[1]\n\n\n\n\n\n\n0\n\n\n0\n\n\nOFF\n\n\n\n\n0\n\n\n1\n\n\nOFF\n\n\n\n\n1\n\n\n0\n\n\nOFF\n\n\n\n\n1\n\n\n1\n\n\nON\n\n\n\n\n\n\n\n\n\n\nled[2]\n\n\n\n\n\n\nBlink at 2.4 Hz\n\n\n\n\n\n\n\n\nDesign\nTo organize my thoughts I used a block diagram to map the logic.\n\n\n\nLab 1 Block Diagram\n\n\n\nLed Logic Design\nThe truth tables revealed that led[0] behaves as an XOR gate with inputs S1 and S0 and that led[1] behaves as an AND gate with inputs S3 and S2.\nTo have led[2] to blink at 2.4 Hz, I utilized the internal 48 gHz high speed oscillator from the HSOSC Library. A frequency of 2.4 Hz would have a full cycle of 0.4167 second. Dividing this by the frequency of the internal oscillator, we get that a full cycle would require \\(2*10^7\\) ticks. To achieve a duty cycle of 50%, I implemented a flip flop that switched led[2] every \\(10^7\\) clicks.\n\n\nSeven Segment Logic Design\nTo interface the seven segment display with the board, I conferred with the datasheet to determine resistor values. \n\n\n\nResistor Calculations for Seven Segment Display\n\n\nI opted to use resistor values of 240 ohms, producing 6.25 mA of current.\nA wiring schematic is shown below. \nHere is a photo of the implemented design!"
  },
  {
    "objectID": "labs/lab1/lab1.html#testing",
    "href": "labs/lab1/lab1.html#testing",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Testing",
    "text": "Testing\n\nTo verify that the design would work as expected, I ran simulations on ModelSim. To do, I instantiated a test bench that would test all 16 possible inputs of the dip switch to ensure the LED and seven segment display output as expected.\n\n\n\nWave forms of test bench\n\n\nI tested the blinking led[2] with the oscilliscope to confirm it had a frequency of 2.4 hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\n\n\nIn all, Lab 1 offered a cohesive introduction to the work flow for the coming labs. I was able to practice my sodering technique, interfacing with different software, assigning pins, and testing my design with ModelSim.\nThe design meets all the requirements. I spent roughly 15 hours on this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "The source code for the project can be found in the associated Github repository."
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction-learning-objectives",
    "href": "labs/lab5/lab5.html#introduction-learning-objectives",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "The source code for the project can be found in the associated Github repository."
  },
  {
    "objectID": "labs/lab5/lab5.html#design",
    "href": "labs/lab5/lab5.html#design",
    "title": "Lab 5: Interrupts",
    "section": "Design",
    "text": "Design\n\nMCU Design\n\n\nHardware Design"
  },
  {
    "objectID": "labs/lab5/lab5.html#testing-debugging",
    "href": "labs/lab5/lab5.html#testing-debugging",
    "title": "Lab 5: Interrupts",
    "section": "Testing & Debugging",
    "text": "Testing & Debugging"
  },
  {
    "objectID": "labs/lab5/lab5.html#implementation",
    "href": "labs/lab5/lab5.html#implementation",
    "title": "Lab 5: Interrupts",
    "section": "Implementation",
    "text": "Implementation"
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "Lab 5: Interrupts",
    "section": "Conclusion",
    "text": "Conclusion\nLab 5 meets all the requirements, and took me approximately XXX hours to complete"
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In Lab 3, I designed and constructed a circuit on my FPGA to read a 4-by-4 matrix keypad and display the last two hexadecimal digits pressed on dual seven-segment displays. My design satisfied all the requirements, including:\n\n\nDesign does not lock up when multiple buttons are pressed at once.\n\n\nDesign only registers first button press if additional buttons are pressed down while holding down one button.\n\n\nEach button press registered only once (e.g., no switch bouncing)\n\n\nSeven segment displays are same brightness regardless of how many segments are illuminated.\n\n\nDesign has no latches.\n\n\nDesign has no tristate buffers.\n\n\nDesign uses synchronizers on asynchronous inputs to mitigate metastability.\n\n\nThe source code for the project can be found in the associated Github repository."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction-learning-objectives",
    "href": "labs/lab3/lab3.html#introduction-learning-objectives",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In Lab 3, I designed and constructed a circuit on my FPGA to read a 4-by-4 matrix keypad and display the last two hexadecimal digits pressed on dual seven-segment displays. My design satisfied all the requirements, including:\n\n\nDesign does not lock up when multiple buttons are pressed at once.\n\n\nDesign only registers first button press if additional buttons are pressed down while holding down one button.\n\n\nEach button press registered only once (e.g., no switch bouncing)\n\n\nSeven segment displays are same brightness regardless of how many segments are illuminated.\n\n\nDesign has no latches.\n\n\nDesign has no tristate buffers.\n\n\nDesign uses synchronizers on asynchronous inputs to mitigate metastability.\n\n\nThe source code for the project can be found in the associated Github repository."
  },
  {
    "objectID": "labs/lab3/lab3.html#design",
    "href": "labs/lab3/lab3.html#design",
    "title": "Lab 3: Keypad Scanner",
    "section": "Design",
    "text": "Design\nTo quote Professor Brake, “This is a thinking person’s lab.” As such, I spent a fair amount of time designing a Finite State Machine (FSM) to read the in the matrix keypad inputs, and then creating a block diagram to understand how my modules will intersect.\n\nScanning FSM\nThe FSM to read the inputs worked by cycling through pulling each row to high, and looking to see if any of the columns were high, which was tracked in the keyPressed variable. If the FSM found that a key was pressed, it would enter a waiting stage until the button was unpressed. I handled decoding the row and colomn pairs wihtin my FSM module with my scanDecoder module. This allowed me to output the keyDecoded, keyPressed, and the rows from the scanFSM module to interact with other modules. \n\n\nKey Debouncing FSM\nI then passed through keyDecoded and keyPressed into the keyBounce module, that used an FSM to deal with key debouncing. This FSM had four states: a waiting state, a counting state, a printing state, and then a holding state. The FSM is in the waiting state until keyPressed is high. Once the key is pressed, a counter is triggered. Once the counter reaches a threshold value, then an enabled signal is activated and the signal is displayed on the seven segment display. Then the FSM enters the holding state until the button is unpressed.\n\n\n\nButton Debouncing FSM\n\n\n\n\nSeven Segment Display\nWith the keyBounce FSM, a shifter module was called to shift the display on the dual seven segment display and show the new value. The keyBounce FSM ultimately served to disregard quick, high signals.\nPrinting and multiplexing the seven segment display was handled with the code from Lab 2\n\n\nDesign Tradeoffs\n\nMy design was broken up into many different modules, with different FSMs or combinational logic being used to implement my design. I opted for this approach so that it would be easier to test smaller behaviors, and allowed me to edit functionalities without impacting other functionalities.\nFor example, to implement switch debouncing, I implemented a FSM with different states. At first, I attempted an approach without an FSM – using a lot of if statements. However, as the behavior got more complicated, I started to infer latches. To stop this, I opted to draw an FSM so that I can step away from “thinking like a programmer” and start thinking about the hardware.\nA block diagram of my entire design is here:"
  },
  {
    "objectID": "labs/lab3/lab3.html#simulation-and-testing",
    "href": "labs/lab3/lab3.html#simulation-and-testing",
    "title": "Lab 3: Keypad Scanner",
    "section": "Simulation and Testing",
    "text": "Simulation and Testing\nThe first step here was to test all the modules in modelSim before running on Radiant. This avoided many headaches – as I wrote test benches for each individual model to ensure expected behavior.\nMy waveforms for each model is below: \n\n\n\nShifter Test Bench\n\n\n\n\n\nkeyBounce Test Bench\n\n\nMy mux, sum, and sevensegments module was taken from Lab 2, where I implemented test benches last week."
  },
  {
    "objectID": "labs/lab3/lab3.html#implementation",
    "href": "labs/lab3/lab3.html#implementation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Implementation",
    "text": "Implementation\nThe circuit diagram of my implementation, including pin mapping, is here: \n\nDebugging in Implementation\nDuring the implementation of my design, I encountered a few bugs. In doing so, using the oscilloscope ot visualize which rows are high allowed me to isolate bugs in my FSM. Additionally, the oscilloscope helped me decide the threshold value for my key debouncing module.\n\n\nHandling Metastability\nTo handle metastability, I implemented two flip flops and temporary variables to try to line the async input with the clock edge."
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Conclusion",
    "text": "Conclusion\nLab 3 proved that simulation prior to implementation is a necessity. As a result, I grew familiar with fully defining my system, and how to debug.\nLab 3 meets all the requirements, and took me approximately 30 hours to complete"
  },
  {
    "objectID": "posts/post5.html",
    "href": "posts/post5.html",
    "title": "The Art in PCB Design",
    "section": "",
    "text": "In class this week, my peers and I are designing our own printed circuit board (PCB) using KiCad. This custom PCB board will interface with the DS1722 temperature sensor integrated circuit (IC). At the end of the week, our designs will be sent to be manufactured so that we can use them in Lab 7.\nPCBs are made up of a layers of substrate, copper, solder mask, solder finish, etc. These boards are the fundamental building blocks of any embedded system, ranging from simple boards that interface with temperature sensors to complex applications like computers, watches, and stereo systems.\nWhile PCBs are all around us, they remain invisible to most – hidden behind their protective encasings. Yet, the time and effort that engineers invest in these intricate components are far from neglible. In fact, to me, there seems to be a level of artistry involved in crafting a PCB, in both the technical layout and silkscreen designs. Engineers have the option of investing more effort to make their designs follow common standards, scalable, and easy to understand. This in itself is a feat to be appreciated by any future engineer or maker that will use their design. However, some engineers seem to go even farther, and become artists when designing these boards; And while this art is invisible to many, others who interact with the PCB can appreciate this.\nThe examples of PCBs as art seems to fall under three umbrellas:"
  },
  {
    "objectID": "posts/post5.html#silkscreen-easter-eggs",
    "href": "posts/post5.html#silkscreen-easter-eggs",
    "title": "The Art in PCB Design",
    "section": "1. Silkscreen Easter Eggs",
    "text": "1. Silkscreen Easter Eggs\nIn this category, designers integrate an unnecessary design into the silkscreen layer.\nThe silkscreen layer is commonly used to offer some level of applicable knowledge, like the revision history or operation data. However, some designers also integrate non-essential designs into the silkscreen layer.\n   \nThese designs could have been an inside joke for the design team, a signature, a political statement, or even a fun easter egg for the unexpected observer. Nonetheless, I think it is inherently beautiful that designer and engineers add these hidden detail for fellow engineers, fixers, and curious minds to stumble upon."
  },
  {
    "objectID": "posts/post5.html#craftsmanship",
    "href": "posts/post5.html#craftsmanship",
    "title": "The Art in PCB Design",
    "section": "2. Craftsmanship",
    "text": "2. Craftsmanship\nThere is also the category of craftsmanship. This includes engineers that take pride in their craftsmanship, whether that be implementing an elegant solution to make a design more compact or completing a beautiful solder job. There’s something immensely satisfying about the precision and care that goes into attempting “perfection.”\nIf you have ever thought, “wow, that is a beautiful soldering job,” that would fall under this category.\n\nThis type of art also brings to mind the transparent electronics of the 90s, where the internal circuitry were a feature of the product – actively contributing to a very specific aesthetic that emphasizes the beauty of engineerings."
  },
  {
    "objectID": "posts/post5.html#pcb-look-for-other-applications",
    "href": "posts/post5.html#pcb-look-for-other-applications",
    "title": "The Art in PCB Design",
    "section": "3. PCB Look for other Applications",
    "text": "3. PCB Look for other Applications\nThere are also designs that capitalize on the PCB look, without any thought for technical purposes. These creations often embrace the classic green plated copper look, but step away from practical uses.\nAn example of this is the entry badge for a maker convention I went to this past summer with my brother. These badges were working PCBs – able to light up two LEDs if you soldered it. However, they were definitely designed for the primary use of a badge – being irregularly shaped and larger than needed to light up two LEDs."
  },
  {
    "objectID": "posts/post3.html",
    "href": "posts/post3.html",
    "title": "The Embedded Systems Surrounding us",
    "section": "",
    "text": "Throughout this course, I have been working with an MCU and FPGA extensively. As I do so, I admire the reprogrammable aspects, allowing me to test and implement a variety of systems. On the other end of this “reusability spectrum” spectrum lies the embedded system, which a specialized computer system for a specific task. In my blog this week, I want to look more at the embedded systems that surround me.\nFor starters, I wear an apple watch – a combination of sensors, software, and hardware on my wrist. This specialized system is able to monitor my daily steps, heartbeat, movements, as well as connect with my phone to share text messages. The apple watch uses an accelerometer, a gyroscope, a barometer, a Force Touch Sensor, and a Heart Rate Sensor. The accelerometer and gyroscope are critical for detecting orientation and movements – and seem quite intuitive to include. The barometer seems less intuitive – however the pressure readings can indicate elevation changes. The Force Touch Sensor is useful for inputing user’s intentions as they touch the screen. Finally, the Heart Rate Sensor uses photoplethysmography (light) to measure heart rate. I am always amazed by the accuracy of the apple watch. I often use my watch to record my swim workouts, and sometimes compare the stroke breakdown and yardage to reality, and am impresssed by how similair it is.\n\nAnother embedded system is my digital camera, which is able to perform image processing, autofocus, exposure, and picture stabilization. It features a variety of settings, spanning from completely manual to specialized automatic modes – like portrait and landscape mode.\nAir conditioning is also another embedded system. We recently just had a heat wave, with temperatures reaching 112 degrees. During which, the air conditioning broke. The HVAC system used in my dorm required replacements for highly specialized parts, which were difficult to source. This points out a down side of embedded systems – due to their task-specific nature, as embedded systems phase out, the parts and documentation can be hard to find."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Victoria Parizot - Norwalk, CT\nVictoria Parizot is a senior at Harvey Mudd College, majoring in engineering. She is most interested with mechanical and electrical engineering, and excited to be taking “Microprocessor Systems: Design & Application” (AKA MicroPs)!\nAt Harvey Mudd, she is a West Dorm President and a Machine Shop Proctor. In her free time, she enjoys woodworking in the machine shop, taking and developing film photos, and sailing."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "MicroPs Resources",
    "section": "",
    "text": "To learn more about the MicroPs Course, and the motivation of the labs, look at the MicroPs website."
  }
]